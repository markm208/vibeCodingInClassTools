<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Git Workflow Simulator</title>
    <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;500;600;700&family=Space+Grotesk:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg-dark: #0d1117;
            --bg-panel: #161b22;
            --bg-input: #0d1117;
            --border: #30363d;
            --text-primary: #e6edf3;
            --text-secondary: #8b949e;
            --text-muted: #6e7681;
            --accent-blue: #58a6ff;
            --accent-green: #3fb950;
            --accent-purple: #a371f7;
            --accent-orange: #d29922;
            --accent-red: #f85149;
            --accent-pink: #db61a2;
            --success-bg: rgba(63, 185, 80, 0.15);
            --warning-bg: rgba(210, 153, 34, 0.15);
            --error-bg: rgba(248, 81, 73, 0.15);
        }

        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Space Grotesk', sans-serif;
            background: var(--bg-dark);
            color: var(--text-primary);
            min-height: 100vh;
            overflow-x: hidden;
        }

        .app-container {
            display: grid;
            grid-template-columns: 280px 1fr 280px;
            grid-template-rows: auto 1fr auto;
            height: 100vh;
            gap: 1px;
            background: var(--border);
        }

        /* Header */
        .header {
            grid-column: 1 / -1;
            background: var(--bg-panel);
            padding: 1rem 1.5rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            border-bottom: 1px solid var(--border);
        }

        .header h1 {
            font-size: 1.25rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 0.75rem;
        }

        .header h1::before {
            content: '';
            width: 24px;
            height: 24px;
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
            border-radius: 6px;
        }

        .current-branch {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
        }

        .branch-icon {
            color: var(--accent-purple);
        }

        /* Main Content Area */
        .main-content {
            background: var(--bg-dark);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        /* Code Editor */
        .editor-container {
            flex: 1;
            display: flex;
            flex-direction: column;
            background: var(--bg-panel);
            margin: 1rem;
            border-radius: 8px;
            border: 1px solid var(--border);
            overflow: hidden;
            min-height: 0;
        }

        .editor-header {
            display: flex;
            align-items: center;
            padding: 0.75rem 1rem;
            background: var(--bg-input);
            border-bottom: 1px solid var(--border);
            gap: 0.5rem;
            flex-shrink: 0;
        }

        .file-tab {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem 1rem;
            background: var(--bg-panel);
            border-radius: 6px 6px 0 0;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.8rem;
            border: 1px solid var(--border);
            border-bottom: none;
            margin-bottom: -1px;
        }

        .file-icon {
            color: var(--accent-blue);
        }

        .file-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: var(--text-muted);
        }

        .file-status.modified {
            background: var(--accent-orange);
        }

        .file-status.staged {
            background: var(--accent-green);
        }

        .file-status.conflict {
            background: var(--accent-red);
            animation: conflictBlink 0.8s ease-in-out infinite;
        }

        @keyframes conflictBlink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.4; }
        }

        .editor-body {
            flex: 1;
            display: flex;
            position: relative;
            overflow: hidden;
            min-height: 0;
        }

        .line-numbers {
            padding: 1rem 0.75rem;
            background: var(--bg-input);
            border-right: 1px solid var(--border);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            color: var(--text-muted);
            text-align: right;
            user-select: none;
            line-height: 1.6;
            min-width: 3rem;
            white-space: pre;
            overflow-y: auto;
        }

        .code-input {
            flex: 1;
            background: var(--bg-panel);
            border: none;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            padding: 1rem;
            resize: none;
            line-height: 1.6;
            outline: none;
            overflow-y: auto;
        }

        .code-input::placeholder {
            color: var(--text-muted);
        }

        .code-input:disabled {
            opacity: 0.6;
            cursor: not-allowed;
        }

        /* Actions Panel */
        .actions-panel {
            padding: 1rem;
            background: var(--bg-panel);
            margin: 0 1rem 1rem 1rem;
            border-radius: 8px;
            border: 1px solid var(--border);
            flex-shrink: 0;
        }

        .actions-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(140px, 1fr));
            gap: 0.75rem;
        }

        .action-btn {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 0.5rem;
            padding: 1rem;
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 8px;
            color: var(--text-primary);
            font-family: 'Space Grotesk', sans-serif;
            font-size: 0.8rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .action-btn:hover:not(:disabled) {
            border-color: var(--accent-blue);
            background: rgba(88, 166, 255, 0.1);
        }

        .action-btn:disabled {
            opacity: 0.4;
            cursor: not-allowed;
        }

        .action-btn .icon {
            font-size: 1.5rem;
        }

        .action-btn.primary {
            background: linear-gradient(135deg, var(--accent-purple), var(--accent-blue));
            border-color: transparent;
        }

        .action-btn.primary:hover:not(:disabled) {
            opacity: 0.9;
            transform: translateY(-1px);
        }

        .action-btn.success {
            border-color: var(--accent-green);
            background: var(--success-bg);
        }

        .action-btn.warning {
            border-color: var(--accent-orange);
            background: var(--warning-bg);
        }

        .action-btn.danger {
            border-color: var(--accent-red);
            background: var(--error-bg);
            animation: pulse 1.5s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% {
                box-shadow: 0 0 0 0 rgba(248, 81, 73, 0.4);
            }
            50% {
                box-shadow: 0 0 0 8px rgba(248, 81, 73, 0);
            }
        }

        /* Sidebars */
        .sidebar-left,
        .sidebar-right {
            background: var(--bg-panel);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            min-height: 0;
        }

        /* Resize Handle */
        .resize-handle {
            width: 5px;
            background: var(--border);
            cursor: col-resize;
            transition: background 0.2s ease;
            position: relative;
        }

        .resize-handle:hover,
        .resize-handle.dragging {
            background: var(--accent-purple);
        }

        .resize-handle::after {
            content: '';
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 3px;
            height: 40px;
            background: var(--text-muted);
            border-radius: 2px;
            opacity: 0;
            transition: opacity 0.2s ease;
        }

        .resize-handle:hover::after,
        .resize-handle.dragging::after {
            opacity: 1;
            background: white;
        }

        .sidebar-section {
            padding: 1rem;
            border-bottom: 1px solid var(--border);
            flex-shrink: 0;
        }

        .sidebar-section h3 {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
        }

        /* Progress */
        .progress-container {
            display: flex;
            flex-direction: column;
            gap: 0.75rem;
        }

        .progress-bar-wrapper {
            background: var(--bg-input);
            border-radius: 999px;
            height: 8px;
            overflow: hidden;
        }

        .progress-bar {
            height: 100%;
            background: linear-gradient(90deg, var(--accent-green), var(--accent-blue));
            border-radius: 999px;
            transition: width 0.5s ease;
        }

        .progress-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: var(--text-secondary);
        }

        /* Checklist */
        .checklist {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .checklist-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem;
            border-radius: 6px;
            font-size: 0.8rem;
            color: var(--text-secondary);
            transition: all 0.2s ease;
        }

        .checklist-item.completed {
            color: var(--accent-green);
            background: var(--success-bg);
        }

        .checklist-item.current {
            color: var(--accent-blue);
            background: rgba(88, 166, 255, 0.1);
        }

        .check-icon {
            width: 18px;
            height: 18px;
            border: 2px solid currentColor;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-size: 0.7rem;
            flex-shrink: 0;
        }

        .checklist-item.completed .check-icon {
            background: var(--accent-green);
            border-color: var(--accent-green);
            color: var(--bg-dark);
        }

        /* Branch Visualization */
        .branch-viz {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .branch-item {
            display: flex;
            align-items: center;
            gap: 0.75rem;
            padding: 0.5rem 0.75rem;
            border-radius: 6px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.75rem;
            background: var(--bg-input);
            border: 1px solid var(--border);
        }

        .branch-item.active {
            border-color: var(--accent-purple);
            background: rgba(163, 113, 247, 0.1);
        }

        .branch-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--text-muted);
        }

        .branch-item.active .branch-dot {
            background: var(--accent-purple);
        }

        .branch-item.main .branch-dot {
            background: var(--accent-green);
        }

        /* Activity Log */
        .log-container {
            flex: 1;
            overflow-y: auto;
            padding: 1rem;
            min-height: 0;
        }

        .log-container h3 {
            font-size: 0.75rem;
            font-weight: 600;
            text-transform: uppercase;
            letter-spacing: 0.05em;
            color: var(--text-secondary);
            margin-bottom: 0.75rem;
            position: sticky;
            top: 0;
            background: var(--bg-panel);
            padding: 0.25rem 0;
        }

        .log-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .log-item {
            display: flex;
            gap: 0.75rem;
            padding: 0.75rem;
            background: var(--bg-input);
            border-radius: 6px;
            font-size: 0.75rem;
            animation: slideIn 0.3s ease;
        }

        @keyframes slideIn {
            from {
                opacity: 0;
                transform: translateX(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(0);
            }
        }

        .log-item.reviewing {
            border: 1px solid var(--accent-blue);
            animation: reviewPulse 1s ease-in-out infinite;
        }

        .log-item.teammate-pending {
            border: 1px solid var(--accent-red);
            animation: teammatePulse 1s ease-in-out infinite;
        }

        .log-item.changes-requested {
            border: 1px solid var(--accent-orange);
            animation: changesPulse 1s ease-in-out infinite;
        }

        @keyframes changesPulse {
            0%, 100% {
                border-color: var(--accent-orange);
                box-shadow: 0 0 5px rgba(210, 153, 34, 0.3);
            }
            50% {
                border-color: var(--accent-red);
                box-shadow: 0 0 15px rgba(210, 153, 34, 0.5);
            }
        }

        @keyframes teammatePulse {
            0%, 100% {
                border-color: var(--accent-red);
                box-shadow: 0 0 5px rgba(248, 81, 73, 0.3);
            }
            50% {
                border-color: var(--accent-orange);
                box-shadow: 0 0 15px rgba(248, 81, 73, 0.5);
            }
        }

        @keyframes reviewPulse {
            0%, 100% {
                border-color: var(--accent-blue);
                box-shadow: 0 0 5px rgba(88, 166, 255, 0.3);
            }
            50% {
                border-color: var(--accent-purple);
                box-shadow: 0 0 15px rgba(163, 113, 247, 0.5);
            }
        }

        .log-icon {
            font-size: 1rem;
            flex-shrink: 0;
        }

        .log-content {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
        }

        .log-message {
            color: var(--text-primary);
        }

        .log-detail {
            color: var(--text-muted);
            font-family: 'JetBrains Mono', monospace;
        }

        .log-location {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            font-size: 0.65rem;
            padding: 0.2rem 0.5rem;
            border-radius: 4px;
            margin-top: 0.35rem;
            width: fit-content;
        }

        .log-location.local {
            background: rgba(163, 113, 247, 0.15);
            color: var(--accent-purple);
            border: 1px solid rgba(163, 113, 247, 0.3);
        }

        .log-location.sending {
            background: rgba(210, 153, 34, 0.15);
            color: var(--accent-orange);
            border: 1px solid rgba(210, 153, 34, 0.3);
        }

        .log-location.github {
            background: rgba(88, 166, 255, 0.15);
            color: var(--accent-blue);
            border: 1px solid rgba(88, 166, 255, 0.3);
        }

        .location-icon {
            font-size: 0.75rem;
        }

        .code-preview {
            margin-top: 0.5rem;
            padding: 0.5rem;
            background: var(--bg-dark);
            border: 1px solid var(--border);
            border-radius: 4px;
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.65rem;
            line-height: 1.5;
            white-space: pre;
            color: var(--text-secondary);
            max-height: 150px;
            overflow: auto;
        }

        /* Explanation Toggle */
        .explanation-toggle {
            display: flex;
            align-items: center;
            gap: 0.35rem;
            font-size: 0.65rem;
            color: var(--accent-green);
            cursor: pointer;
            margin-top: 0.35rem;
            padding: 0.2rem 0;
            user-select: none;
        }

        .explanation-toggle:hover {
            color: var(--accent-blue);
        }

        .explanation-box {
            margin-top: 0.5rem;
            padding: 0.6rem;
            background: var(--bg-dark);
            border: 2px solid var(--accent-green);
            border-radius: 6px;
            font-size: 0.7rem;
            line-height: 1.5;
            color: var(--text-primary);
            animation: slideDown 0.2s ease;
            cursor: pointer;
        }

        .explanation-box:hover {
            border-color: var(--accent-blue);
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-5px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        /* Status Bar */
        .status-bar {
            grid-column: 1 / -1;
            background: var(--bg-panel);
            padding: 0.5rem 1rem;
            display: flex;
            align-items: center;
            justify-content: space-between;
            font-size: 0.75rem;
            color: var(--text-secondary);
            border-top: 1px solid var(--border);
        }

        .status-left, .status-right {
            display: flex;
            align-items: center;
            gap: 1rem;
        }

        .status-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .status-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
        }

        .status-dot.green {
            background: var(--accent-green);
        }

        .status-dot.orange {
            background: var(--accent-orange);
        }

        .status-dot.red {
            background: var(--accent-red);
        }

        /* Modal */
        .modal-overlay {
            position: fixed;
            inset: 0;
            background: rgba(0, 0, 0, 0.7);
            display: flex;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            animation: fadeIn 0.2s ease;
        }

        @keyframes fadeIn {
            from { opacity: 0; }
            to { opacity: 1; }
        }

        .modal {
            background: var(--bg-panel);
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 1.5rem;
            max-width: 500px;
            width: 90%;
            animation: scaleIn 0.2s ease;
            max-height: 80vh;
            overflow-y: auto;
        }

        @keyframes scaleIn {
            from {
                opacity: 0;
                transform: scale(0.95);
            }
            to {
                opacity: 1;
                transform: scale(1);
            }
        }

        .modal h2 {
            font-size: 1.25rem;
            margin-bottom: 1rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .modal p {
            color: var(--text-secondary);
            font-size: 0.875rem;
            margin-bottom: 1rem;
            line-height: 1.6;
            white-space: pre-wrap;
        }

        .modal-input {
            width: 100%;
            padding: 0.75rem;
            background: var(--bg-input);
            border: 1px solid var(--border);
            border-radius: 6px;
            color: var(--text-primary);
            font-family: 'JetBrains Mono', monospace;
            font-size: 0.875rem;
            margin-bottom: 1rem;
            outline: none;
        }

        .modal-input:focus {
            border-color: var(--accent-blue);
        }

        .modal-buttons {
            display: flex;
            gap: 0.75rem;
            justify-content: flex-end;
        }

        .modal-btn {
            padding: 0.5rem 1rem;
            border-radius: 6px;
            font-family: 'Space Grotesk', sans-serif;
            font-size: 0.875rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s ease;
        }

        .modal-btn.cancel {
            background: var(--bg-input);
            border: 1px solid var(--border);
            color: var(--text-primary);
        }

        .modal-btn.confirm {
            background: var(--accent-blue);
            border: 1px solid var(--accent-blue);
            color: white;
        }

        .modal-btn:hover {
            opacity: 0.9;
        }

        /* Toast Notification */
        .toast {
            position: fixed;
            bottom: 4rem;
            left: 50%;
            transform: translateX(-50%);
            background: var(--bg-panel);
            border: 1px solid var(--border);
            padding: 1rem 1.5rem;
            border-radius: 8px;
            display: flex;
            align-items: center;
            gap: 0.75rem;
            font-size: 0.875rem;
            z-index: 1001;
            animation: toastIn 0.3s ease;
            box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        }

        @keyframes toastIn {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(20px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        .toast.success {
            border-color: var(--accent-green);
        }

        .toast.error {
            border-color: var(--accent-red);
        }

        .toast.info {
            border-color: var(--accent-blue);
        }

        /* Celebration */
        .celebration {
            position: fixed;
            inset: 0;
            pointer-events: none;
            z-index: 1002;
        }

        .confetti {
            position: absolute;
            width: 10px;
            height: 10px;
            animation: confettiFall 3s ease-out forwards;
        }

        @keyframes confettiFall {
            0% {
                transform: translateY(-100vh) rotate(0deg);
                opacity: 1;
            }
            100% {
                transform: translateY(100vh) rotate(720deg);
                opacity: 0;
            }
        }

        /* Responsive */
        @media (max-width: 1100px) {
            .app-container {
                grid-template-columns: 1fr;
            }

            .sidebar-left,
            .sidebar-right,
            .resize-handle {
                display: none;
            }
        }
    </style>
</head>
<body>
    <div id="app"></div>

    <script src="https://unpkg.com/react@18/umd/react.production.min.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.production.min.js"></script>
    <script src="https://unpkg.com/@babel/standalone/babel.min.js"></script>

    <script type="text/babel">
        const { useState, useEffect, useRef } = React;

        // Workflow steps
        const WORKFLOW_STEPS = [
            { id: 'create_branch', label: 'Create feature branch', icon: 'üåø' },
            { id: 'write_code', label: 'Write code', icon: '‚úèÔ∏è' },
            { id: 'stage_changes', label: 'Stage changes', icon: 'üì¶' },
            { id: 'commit', label: 'Commit changes', icon: 'üíæ' },
            { id: 'push', label: 'Push to remote', icon: '‚¨ÜÔ∏è' },
            { id: 'create_pr', label: 'Create pull request', icon: 'üìã' },
            { id: 'code_review', label: 'Request code review', icon: 'üëÄ' },
            { id: 'approve_pr', label: 'Get PR approved', icon: '‚úÖ' },
            { id: 'merge', label: 'Merge to main', icon: 'üîÄ' },
            { id: 'release', label: 'Ready for release', icon: 'üöÄ' },
        ];

        const STARTER_CODE = `#include <iostream>
using namespace std;

int main() {
    // TODO: Add your code here
    
    return 0;
}`;

        // Beginner-friendly explanations for each log action
        const LOG_EXPLANATIONS = {
            'Created branch': 'üìÇ You made a copy of the main code to work on. Think of it like making a draft copy of a document so you can edit it without changing the original.',
            'Staged changes': 'üì• You selected which changes to save. Staging is like putting items in a shopping cart before checkout. The changes are ready to be saved, but not saved yet.',
            'Committed': 'üíæ You saved a snapshot of your code. This is like saving your game. You can always come back to this exact point later if something goes wrong.',
            'Pushed to origin': '‚òÅÔ∏è You uploaded your saved work to GitHub. Now your code is backed up online and your teammates can see it.',
            'Pull request created': 'üìù You asked your team to review your code before adding it to the main project. This is like submitting a paper for review before publishing.',
            'Requested code review': 'üë• You asked a teammate to look at your code. They will check for bugs, suggest improvements, and make sure the code meets team standards.',
            'PR approved': 'üéâ A teammate reviewed your code and said it looks good! You now have permission to add your changes to the main project.',
            'Merged to main': 'üîó Your code is now part of the main project! Everyone on the team will get your changes the next time they pull.',
            'Teammate pushed to main': '‚ö° Someone else on your team added their code to main. You should pull their changes so you have the latest version.',
            'Pulled latest from main': '‚¨áÔ∏è You downloaded the newest version of the code from GitHub. Your local copy is now up to date with what the team has.',
            'Merge conflict': '‚ö†Ô∏è You and a teammate both changed the same lines of code. Git does not know which version to keep, so you need to manually pick which changes to use.',
            'Changes requested': 'üìù The reviewer wants you to make some edits before approving. This is normal! Make the changes, commit, push, and ask for another review.'
        };

        // Get explanation for a log message
        const getExplanation = (message) => {
            for (const [key, explanation] of Object.entries(LOG_EXPLANATIONS)) {
                if (message.includes(key) || message.startsWith(key)) {
                    return explanation;
                }
            }
            return null;
        };

        function App() {
            const [code, setCode] = useState(STARTER_CODE);
            const [savedCode, setSavedCode] = useState(STARTER_CODE);
            const [stagedCode, setStagedCode] = useState('');
            const [currentBranch, setCurrentBranch] = useState('main');
            const [branches, setBranches] = useState(['main']);
            const [completedSteps, setCompletedSteps] = useState([]);
            const [currentStep, setCurrentStep] = useState(0);
            const [logs, setLogs] = useState([]);
            const [modal, setModal] = useState(null);
            const [toast, setToast] = useState(null);
            const [hasUnstagedChanges, setHasUnstagedChanges] = useState(false);
            const [hasStagedChanges, setHasStagedChanges] = useState(false);
            const [isPushed, setIsPushed] = useState(false);
            const [prCreated, setPrCreated] = useState(false);
            const [reviewRequested, setReviewRequested] = useState(false);
            const [prApproved, setPrApproved] = useState(false);
            const [showCelebration, setShowCelebration] = useState(false);
            const [reviewCountdown, setReviewCountdown] = useState(null);
            const [mainBranchCode, setMainBranchCode] = useState(STARTER_CODE);
            const [teammateChangePending, setTeammateChangePending] = useState(false);
            const [hasConflict, setHasConflict] = useState(false);
            const [teammateChangeUsed, setTeammateChangeUsed] = useState(false);
            const [changesRequested, setChangesRequested] = useState(false);
            const [pulledBeforePR, setPulledBeforePR] = useState(false);
            const [rightSidebarWidth, setRightSidebarWidth] = useState(280);
            const [isResizing, setIsResizing] = useState(false);
            const textareaRef = useRef(null);

            // Check for unsaved changes
            useEffect(() => {
                const hasChanges = code !== savedCode;
                setHasUnstagedChanges(hasChanges);
            }, [code, savedCode]);

            // Handle resize drag
            useEffect(() => {
                const handleMouseMove = (e) => {
                    if (!isResizing) return;
                    const newWidth = window.innerWidth - e.clientX;
                    // Clamp between 200 and 500px
                    setRightSidebarWidth(Math.min(500, Math.max(200, newWidth)));
                };

                const handleMouseUp = () => {
                    setIsResizing(false);
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                };

                if (isResizing) {
                    document.body.style.cursor = 'col-resize';
                    document.body.style.userSelect = 'none';
                    document.addEventListener('mousemove', handleMouseMove);
                    document.addEventListener('mouseup', handleMouseUp);
                }

                return () => {
                    document.removeEventListener('mousemove', handleMouseMove);
                    document.removeEventListener('mouseup', handleMouseUp);
                };
            }, [isResizing]);

            // Check for conflict markers in code
            const hasConflictMarkers = (codeText) => {
                return codeText.includes('<<<<<<<') || codeText.includes('>>>>>>>') || codeText.includes('=======');
            };

            // Update conflict state when code changes
            useEffect(() => {
                if (hasConflict && !hasConflictMarkers(code)) {
                    setHasConflict(false);
                    showToast('Conflict resolved! You can now stage your changes.', 'success');
                }
            }, [code, hasConflict]);

            // Simulate teammate making changes (with probability after certain actions, max once per cycle)
            const maybeIntroduceTeammateChange = () => {
                // 70% chance of teammate change opportunity, but only once per cycle
                if (Math.random() < 0.7 && !teammateChangePending && !teammateChangeUsed && currentBranch !== 'main') {
                    // Ask user if they want to practice with this scenario
                    setModal({
                        title: 'üë• Teammate Activity Detected!',
                        message: 'LEARNING OPPORTUNITY: Your teammate Sarah wants to merge her changes to main. This could create a merge conflict with your work!\n\nWould you like to practice handling this real-world scenario? You will need to pull her changes and potentially resolve conflicts before continuing.\n\nThis is optional, you can skip it if you want to focus on the basic workflow first.',
                        input: false,
                        cancelText: 'Skip This Time',
                        confirmText: 'Yes, Let\'s Practice!',
                        onConfirm: () => {
                            const teammateCode = mainBranchCode.replace(
                                '// TODO: Add your code here',
                                '// Added by teammate: Sarah\n    cout << "Welcome to our app!" << endl;'
                            );
                            setMainBranchCode(teammateCode);
                            setTeammateChangePending(true);
                            setTeammateChangeUsed(true);
                            addLog('üë•', 'Teammate pushed to main', 'Sarah merged PR: "Add welcome message"', 'github');
                            showToast('Your teammate just pushed changes to main!', 'info');
                            setModal(null);
                        },
                        onCancel: () => {
                            setTeammateChangeUsed(true); // Don't ask again this cycle
                            setModal(null);
                        }
                    });
                }
            };

            // Review countdown timer
            useEffect(() => {
                if (reviewCountdown === null) return;
                
                if (reviewCountdown > 0) {
                    const timer = setTimeout(() => {
                        setReviewCountdown(reviewCountdown - 1);
                        // Update the log entry with new countdown
                        setLogs(prev => prev.map((log, index) => 
                            index === 0 && log.message === 'Requested code review'
                                ? { ...log, detail: `Teammate actively reviewing your code, estimated time to completion ${reviewCountdown - 1} seconds` }
                                : log
                        ));
                    }, 1000);
                    return () => clearTimeout(timer);
                } else {
                    // Countdown finished - 40% chance reviewer might request changes
                    setReviewCountdown(null);
                    const reviewerMightReject = Math.random() < 0.4 && !changesRequested;
                    
                    if (reviewerMightReject) {
                        // Ask user if they want to practice with this scenario
                        setModal({
                            title: 'ü§î Reviewer Has Feedback',
                            message: 'LEARNING OPPORTUNITY: The reviewer noticed something they\'d like you to improve. They could either request changes or approve with a comment.\n\nWould you like to practice handling "Changes Requested"? This teaches you how to iterate on a PR without closing it.\n\nThis is optional, you can skip it if you want to complete this workflow first.',
                            input: false,
                            cancelText: 'Skip, Approve This Time',
                            confirmText: 'Yes, Request Changes!',
                            onConfirm: () => {
                                // Reviewer requests changes
                                setChangesRequested(true);
                                setReviewRequested(false); // Allow requesting review again
                                setIsPushed(false); // Need to push again after making changes
                                addLog('üîÑ', 'Changes requested', 'Reviewer: "Please add a comment explaining this logic"', 'github');
                                showToast('Reviewer requested changes to your PR', 'info');
                                setModal(null);
                                
                                // Show teaching modal after a brief delay
                                setTimeout(() => {
                                    setModal({
                                        title: 'üîÑ Changes Requested',
                                        message: 'WHY: Code reviewers often request changes before approving. This is normal and healthy! It does not mean your code is bad, it means the team is working together to make it better. Common requests include adding comments, improving naming, or handling edge cases.\n\nHOW: You do NOT need to close the PR and start over. Simply:\n1. Make the requested changes in your code\n2. Stage and commit your changes\n3. Push to the same branch\n\nYour new commits will automatically appear in the existing PR. Then request another review.',
                                        input: false,
                                        hideCancel: true,
                                        confirmText: 'Got It, I\'ll Fix It',
                                        onConfirm: () => {
                                            setModal(null);
                                        }
                                    });
                                }, 100);
                            },
                            onCancel: () => {
                                // Reviewer approves
                                setPrApproved(true);
                                addLog('‚úÖ', 'PR approved!', 'Teammate approved your changes', 'github');
                                completeStep('approve_pr');
                                showToast('Your PR has been approved! üéâ', 'success');
                                setModal(null);
                            }
                        });
                    } else {
                        // Reviewer approves
                        setPrApproved(true);
                        addLog('‚úÖ', 'PR approved!', 'Teammate approved your changes', 'github');
                        completeStep('approve_pr');
                        showToast('Your PR has been approved! üéâ', 'success');
                    }
                }
            }, [reviewCountdown, changesRequested]);

            // Line numbers
            const lineCount = code.split('\n').length;
            const lineNumbers = Array.from({ length: lineCount }, (_, i) => i + 1).join('\n');

            // Add log entry
            const addLog = (icon, message, detail, location = 'local', codeSnapshot = null) => {
                setLogs(prev => [{
                    id: Date.now(),
                    icon,
                    message,
                    detail,
                    location,
                    codeSnapshot,
                    explanationOpen: false,
                    time: new Date().toLocaleTimeString()
                }, ...prev]);
            };

            // Show toast
            const showToast = (message, type = 'info') => {
                setToast({ message, type });
                setTimeout(() => setToast(null), 3000);
            };

            // Complete a step
            const completeStep = (stepId) => {
                if (!completedSteps.includes(stepId)) {
                    setCompletedSteps(prev => [...prev, stepId]);
                    const stepIndex = WORKFLOW_STEPS.findIndex(s => s.id === stepId);
                    if (stepIndex >= currentStep) {
                        setCurrentStep(stepIndex + 1);
                    }
                }
            };

            // Actions
            const createBranch = () => {
                if (currentBranch !== 'main') {
                    showToast('You already have a feature branch!', 'error');
                    return;
                }
                if (teammateChangePending) {
                    showToast('Pull latest changes first! Your teammate pushed to main.', 'error');
                    return;
                }
                setModal({
                    title: 'üåø Create New Branch',
                    message: 'WHY: You should never code directly on the main branch. Main represents your production-ready code. By creating a feature branch, you isolate your work so you can experiment, make mistakes, and iterate without affecting the stable codebase.\n\nHOW: Branch names should be descriptive. Common (optional) patterns include "feature/description" or  "bugfix/description". This convention helps teammates understand the purpose of the branch at a glance.',
                    input: true,
                    placeholder: 'feature/add-greeting',
                    onConfirm: (value) => {
                        if (value && value.trim()) {
                            const branchName = value.trim();
                            setBranches(prev => [...prev, branchName]);
                            setCurrentBranch(branchName);
                            setSavedCode(code);
                            addLog('üåø', `Created branch "${branchName}"`, `git checkout -b ${branchName}`, 'local');
                            completeStep('create_branch');
                            showToast(`Switched to new branch: ${branchName}`, 'success');
                            
                            // Show follow-up modal about writing code
                            setTimeout(() => {
                                setModal({
                                    title: '‚úèÔ∏è Write Your Code',
                                    message: 'WHY: Now that you have an isolated branch, you can safely make changes to the code. Any code you write here will not affect the main branch until you complete the full review and merge process.\n\nHOW: Edit the code in the editor. Add a feature, fix a bug, or make any change you want. When you are done, click "Stage Changes" to prepare your changes for a commit.',
                                    input: false,
                                    hideCancel: true,
                                    confirmText: 'Got It',
                                    onConfirm: () => {
                                        setModal(null);
                                    }
                                });
                            }, 100);
                        } else {
                            setModal(null);
                        }
                    }
                });
            };

            const stageChanges = () => {
                if (currentBranch === 'main') {
                    showToast('Create a feature branch first!', 'error');
                    return;
                }
                if (hasConflict || hasConflictMarkers(code)) {
                    showToast('Resolve merge conflicts first! Remove the <<<<<<< ======= >>>>>>> markers.', 'error');
                    return;
                }
                if (teammateChangePending) {
                    showToast('Pull latest changes first! Your teammate pushed to main.', 'error');
                    return;
                }
                if (!hasUnstagedChanges && !hasStagedChanges) {
                    showToast('No changes to stage', 'error');
                    return;
                }
                setModal({
                    title: 'üì¶ Stage Changes',
                    message: 'WHY: Staging is like putting items in a box before shipping. It lets you choose exactly which changes go into your next commit. You might have edited 5 files but only want to commit 2 of them right now. Staging gives you that control.\n\nHOW: Use "git add" to stage specific files, or "git add ." to stage everything. Staged changes appear green in most Git tools.',
                    input: false,
                    confirmText: 'Stage All Changes',
                    onConfirm: () => {
                        setStagedCode(code);
                        setSavedCode(code);
                        setHasStagedChanges(true);
                        setHasUnstagedChanges(false);
                        addLog('üì¶', 'Staged changes', 'git add main.cpp', 'local', code);
                        completeStep('write_code');
                        completeStep('stage_changes');
                        showToast('Changes staged successfully', 'success');
                        setModal(null);
                    }
                });
            };

            const commitChanges = () => {
                if (!hasStagedChanges) {
                    showToast('No staged changes to commit', 'error');
                    return;
                }
                if (hasConflict || hasConflictMarkers(code)) {
                    showToast('Resolve merge conflicts first! Remove the <<<<<<< ======= >>>>>>> markers.', 'error');
                    return;
                }
                setModal({
                    title: 'üíæ Commit Changes',
                    message: 'WHY: A commit is a permanent snapshot of your code at this moment. It creates a save point you can return to. Good commits are small, focused, and represent one logical change. If something breaks later, you can trace back through commits to find when and why.\n\nHOW: Think of your commit message as completing the sentence: "Applying this commit will..." ‚Üí "Add a greeting" not "Added a greeting". This convention reframes what the code does vs. what you did.',
                    input: true,
                    placeholder: 'Add a greeting message to main function',
                    onConfirm: (value) => {
                        if (value && value.trim()) {
                            setHasStagedChanges(false);
                            setIsPushed(false);
                            addLog('üíæ', `Committed: "${value.trim()}"`, `git commit -m "${value.trim()}"`, 'local', stagedCode);
                            completeStep('commit');
                            showToast('Changes committed!', 'success');
                        }
                        setModal(null);
                    }
                });
            };

            const pushChanges = () => {
                if (currentBranch === 'main') {
                    showToast('Cannot push directly to main!', 'error');
                    return;
                }
                if (!completedSteps.includes('commit')) {
                    showToast('Commit your changes first!', 'error');
                    return;
                }
                if (isPushed) {
                    showToast('Already pushed to remote', 'info');
                    return;
                }
                if (teammateChangePending) {
                    showToast('Pull latest changes first! Your teammate pushed to main.', 'error');
                    return;
                }
                setModal({
                    title: '‚¨ÜÔ∏è Push to Remote',
                    message: 'WHY: Your commits only exist on your machine until you push. Pushing uploads your branch and commits to the remote repository (like GitHub). This backs up your work and makes it visible to teammates. It also allows you to create a pull request.\n\nHOW: "git push origin branch-name" sends your local commits to the remote. If this is a new branch, it creates it on the remote too.',
                    input: false,
                    confirmText: 'Push Changes',
                    onConfirm: () => {
                        setIsPushed(true);
                        addLog('‚¨ÜÔ∏è', `Pushed to origin/${currentBranch}`, `git push origin ${currentBranch}`, 'sending');
                        completeStep('push');
                        showToast('Pushed to remote repository!', 'success');
                        setModal(null);
                        
                        // Maybe introduce a teammate change after pushing
                        setTimeout(() => {
                            maybeIntroduceTeammateChange();
                        }, 2000);
                    }
                });
            };

            const createPR = () => {
                if (!isPushed) {
                    showToast('Push your changes first!', 'error');
                    return;
                }
                if (prCreated) {
                    showToast('PR already created', 'info');
                    return;
                }
                if (teammateChangePending) {
                    showToast('Pull latest changes first! Your teammate pushed to main.', 'error');
                    return;
                }
                
                // Helper function to show the actual PR creation modal
                const showPRModal = () => {
                    setModal({
                        title: 'üìã Create Pull Request',
                        message: 'WHY: A Pull Request (PR) is a formal request to merge your branch into main. It is the centerpiece of team collaboration. PRs let teammates see your changes, discuss them, suggest improvements, and catch bugs before they reach production. No code should reach main without a PR.\n\nHOW: Describe what your code does and why. Link to any related issues. Reviewers will read this to understand your changes.',
                        input: true,
                        placeholder: 'Add greeting feature that displays a welcome message',
                        onConfirm: (value) => {
                            if (value && value.trim()) {
                                setPrCreated(true);
                                addLog('üìã', 'Pull request created', `PR: ${currentBranch} ‚Üí main`, 'github');
                                completeStep('create_pr');
                                showToast('Pull request created!', 'success');
                            }
                            setModal(null);
                        }
                    });
                };
                
                // If user hasn't pulled before creating PR, suggest they do so
                if (!pulledBeforePR) {
                    setModal({
                        title: '‚¨áÔ∏è Pull Before Creating PR?',
                        message: 'BEST PRACTICE: Before creating a PR, it is a good idea to pull the latest main into your branch. This catches conflicts early and ensures your PR can merge cleanly.\n\nIf there are conflicts, you can resolve them now rather than surprising your reviewer later.',
                        input: false,
                        cancelText: 'Skip, Create PR',
                        confirmText: 'Pull First',
                        onConfirm: () => {
                            setPulledBeforePR(true);
                            addLog('‚¨áÔ∏è', 'Pulled latest from main', 'git pull origin main', 'sending');
                            showToast('Up to date with main', 'success');
                            setModal(null);
                            // Show PR modal after a brief delay
                            setTimeout(() => {
                                showPRModal();
                            }, 100);
                        },
                        onCancel: () => {
                            setPulledBeforePR(true); // Don't ask again
                            setModal(null);
                            // Show PR modal after a brief delay
                            setTimeout(() => {
                                showPRModal();
                            }, 100);
                        }
                    });
                } else {
                    showPRModal();
                }
            };

            const requestReview = () => {
                if (!prCreated) {
                    showToast('Create a PR first!', 'error');
                    return;
                }
                if (reviewRequested && !changesRequested) {
                    showToast('Review already requested', 'info');
                    return;
                }
                if (changesRequested && !isPushed) {
                    showToast('Push your changes first before requesting another review!', 'error');
                    return;
                }
                setModal({
                    title: 'üëÄ Request Code Review',
                    message: 'WHY: Code review is where teammates examine your code before it merges. Fresh eyes catch bugs, improve code quality, share knowledge across the team, and ensure consistency. Even senior developers have their code reviewed. It is not about criticism; it is about making the code better together.\n\nHOW: Assign reviewers to your PR, they will review your code directly on the pull request page, where they can see exactly what changed. They will leave comments, and either approve, request changes, or just comment. Most teams require at least one approval before merging.',
                    input: false,
                    confirmText: 'Request Review',
                    onConfirm: () => {
                        setReviewRequested(true);
                        setReviewCountdown(5);
                        addLog('üëÄ', 'Requested code review', 'Teammate actively reviewing your code, estimated time to completion 5 seconds', 'github');
                        completeStep('code_review');
                        showToast('Review requested from teammate', 'success');
                        setModal(null);
                    }
                });
            };

            const mergePR = () => {
                if (!prApproved) {
                    showToast('Wait for PR approval first!', 'error');
                    return;
                }
                setModal({
                    title: 'üîÄ Merge Pull Request',
                    message: 'WHY: Merging combines your branch into the main branch, making your changes part of the official codebase. After merging, your feature is available to everyone and typically triggers deployment processes.\n\nHOW: Teams often use "Squash and Merge" to combine all your commits into one clean commit on main. When you click this button on the PR page, GitHub takes all the individual commits from your branch (maybe 5-10 small commits as you iterated) and squashes them into a single commit with a clean message. The PR author or a maintainer with merge permissions initiates this. Your original commits still exist in your branch history, but main only sees one commit. After merging, your feature branch can be deleted since its work is now in main.',
                    input: false,
                    confirmText: 'Squash and Merge',
                    onConfirm: () => {
                        addLog('üîÄ', `Merged ${currentBranch} into main`, 'Squash and merge', 'github');
                        completeStep('merge');
                        setCurrentBranch('main');
                        setPrCreated(false);
                        setReviewRequested(false);
                        setPrApproved(false);
                        setIsPushed(false);
                        setModal(null);
                        
                        // Complete release
                        setTimeout(() => {
                            addLog('üöÄ', 'Ready for release!', 'CI/CD pipeline triggered', 'github');
                            completeStep('release');
                            setShowCelebration(true);
                            setTimeout(() => setShowCelebration(false), 3000);
                            
                            // Show completion modal
                            setTimeout(() => {
                                // 50% chance Sarah adds another change after merge
                                const sarahAddsChange = Math.random() < 0.5;
                                
                                if (sarahAddsChange) {
                                    // Sarah adds a post-merge change - a single line before return 0
                                    const postMergeCode = code.replace(
                                        'return 0;',
                                        '// Added by teammate: Sarah\n    cout << "Thanks for using our app" << endl;\n    \n    return 0;'
                                    );
                                    setMainBranchCode(postMergeCode);
                                    setTeammateChangePending(true);
                                    addLog('üë•', 'Teammate pushed to main', 'Sarah merged PR: "Add thank you message"', 'github');
                                    
                                    setModal({
                                        title: 'üéâ Congratulations!',
                                        message: 'You have successfully completed the entire professional Git workflow!\n\nYou created a feature branch, wrote code, staged and committed your changes, pushed to the remote, created a pull request, had it reviewed and approved, and merged it to main.\n\nThis is exactly how software teams around the world ship code every day. You are now ready to collaborate like a professional developer!\n\n‚ö†Ô∏è Note: Your teammate Sarah just pushed another change to main. Pull the latest changes before continuing.',
                                        input: false,
                                        cancelText: 'Keep Exploring',
                                        confirmText: 'Pull & Continue',
                                        onConfirm: () => {
                                            // Pull Sarah's changes and continue with the existing code
                                            setCode(postMergeCode);
                                            setSavedCode(postMergeCode);
                                            setMainBranchCode(postMergeCode);
                                            setTeammateChangePending(false);
                                            // Reset workflow state but keep the code
                                            setCurrentBranch('main');
                                            setBranches(['main']);
                                            setCompletedSteps([]);
                                            setCurrentStep(0);
                                            setHasUnstagedChanges(false);
                                            setHasStagedChanges(false);
                                            setIsPushed(false);
                                            setPrCreated(false);
                                            setReviewRequested(false);
                                            setPrApproved(false);
                                            setReviewCountdown(null);
                                            setHasConflict(false);
                                            setTeammateChangeUsed(false);
                                            setChangesRequested(false);
                                            setPulledBeforePR(false);
                                            addLog('‚¨áÔ∏è', 'Pulled latest from main', 'Fast-forward merge successful', 'sending');
                                            showToast('Pulled Sarah\'s changes! Create a new branch to continue.', 'success');
                                            setModal(null);
                                        }
                                    });
                                } else {
                                    setModal({
                                        title: 'üéâ Congratulations!',
                                        message: 'You have successfully completed the entire professional Git workflow!\n\nYou created a feature branch, wrote code, staged and committed your changes, pushed to the remote, created a pull request, had it reviewed and approved, and merged it to main.\n\nThis is exactly how software teams around the world ship code every day. You are now ready to collaborate like a professional developer!',
                                        input: false,
                                        cancelText: 'Keep Exploring',
                                        confirmText: 'Start New Workflow',
                                        onConfirm: () => {
                                            resetWorkflow();
                                            setModal(null);
                                        }
                                    });
                                }
                            }, 500);
                        }, 1000);
                    }
                });
            };

            const pullLatest = () => {
                if (teammateChangePending) {
                    // There are actual changes to pull - check for conflicts
                    // Only check for conflicts if we're on a feature branch (not main)
                    const userModifiedTodo = !code.includes('// TODO: Add your code here');
                    const onFeatureBranch = currentBranch !== 'main';
                    
                    if (userModifiedTodo && onFeatureBranch) {
                        // User modified the same area - create a conflict!
                        setModal({
                            title: '‚ö†Ô∏è Merge Conflict Detected!',
                            message: 'WHY: You and your teammate both modified the same part of the code. Git cannot automatically determine which changes to keep, so it marks the conflict and asks you to resolve it manually.\n\nHOW: Git inserts conflict markers showing both versions:\n‚Ä¢ <<<<<<< HEAD marks your changes\n‚Ä¢ ======= separates the two versions\n‚Ä¢ >>>>>>> main marks your teammate\'s changes\n\nYou must edit the file to keep the code you want (usually combining both changes), then remove all the conflict markers before you can commit.',
                            input: false,
                            confirmText: 'I Understand',
                            onConfirm: () => {
                                // Find where user's code is and create conflict
                                const userCode = code;
                                const mainCode = mainBranchCode;
                                
                                // Create conflicted code
                                const conflictedCode = `#include <iostream>
using namespace std;

int main() {
<<<<<<< HEAD (Your changes)
${userCode.split('int main() {')[1].split('return 0;')[0].trim()}
=======
${mainCode.split('int main() {')[1].split('return 0;')[0].trim()}
>>>>>>> main (Teammate's changes)
    
    return 0;
}`;
                                
                                setCode(conflictedCode);
                                setHasConflict(true);
                                setTeammateChangePending(false);
                                addLog('‚ö†Ô∏è', 'Merge conflict!', 'CONFLICT: Both modified main.cpp', 'local');
                                showToast('Resolve the conflict in the editor, then stage your changes', 'error');
                                setModal(null);
                            }
                        });
                    } else {
                        // No conflict - clean merge
                        setModal({
                            title: '‚¨áÔ∏è Pull Latest Changes',
                            message: 'Good news! Your teammate\'s changes don\'t conflict with yours. Git can automatically merge them.\n\nThe changes will be applied to your branch.',
                            input: false,
                            confirmText: 'Pull Changes',
                            onConfirm: () => {
                                setCode(mainBranchCode);
                                setSavedCode(mainBranchCode);
                                setTeammateChangePending(false);
                                addLog('‚¨áÔ∏è', 'Pulled latest from main', 'Fast-forward merge successful', 'sending');
                                showToast('Successfully pulled teammate\'s changes!', 'success');
                                setModal(null);
                            }
                        });
                    }
                } else {
                    setModal({
                        title: '‚¨áÔ∏è Pull Latest Changes',
                        message: 'WHY: While you work on your branch, teammates may have merged their changes to main. Pulling fetches those changes and merges them into your branch. This keeps you up-to-date and helps you catch conflicts early. Always pull before pushing to avoid surprises.\n\nHOW: "git pull origin main" fetches the latest main and merges it into your current branch. If there are conflicts (you both edited the same lines), Git will ask you to resolve them manually.',
                        input: false,
                        confirmText: 'Pull from Main',
                        onConfirm: () => {
                            addLog('‚¨áÔ∏è', 'Pulled latest from main', 'git pull origin main', 'sending');
                            showToast('Already up to date with main', 'success');
                            setModal(null);
                        }
                    });
                }
            };

            const resetWorkflow = () => {
                setCode(STARTER_CODE);
                setSavedCode(STARTER_CODE);
                setStagedCode('');
                setCurrentBranch('main');
                setBranches(['main']);
                setCompletedSteps([]);
                setCurrentStep(0);
                setLogs([]);
                setHasUnstagedChanges(false);
                setHasStagedChanges(false);
                setIsPushed(false);
                setPrCreated(false);
                setReviewRequested(false);
                setPrApproved(false);
                setReviewCountdown(null);
                setMainBranchCode(STARTER_CODE);
                setTeammateChangePending(false);
                setHasConflict(false);
                setTeammateChangeUsed(false);
                setChangesRequested(false);
                setPulledBeforePR(false);
                showToast('Workflow reset!', 'info');
            };

            // Progress calculation
            const progress = (completedSteps.length / WORKFLOW_STEPS.length) * 100;

            // File status
            const fileStatus = hasConflict ? 'conflict' : hasStagedChanges ? 'staged' : hasUnstagedChanges ? 'modified' : '';

            return (
                <div className="app-container" style={{ gridTemplateColumns: `280px 1fr auto ${rightSidebarWidth}px` }}>
                    {/* Header */}
                    <header className="header">
                        <h1>Git Workflow Simulator</h1>
                        <div className="current-branch">
                            <span className="branch-icon">‚éá</span>
                            <span>{currentBranch}</span>
                        </div>
                    </header>

                    {/* Left Sidebar */}
                    <aside className="sidebar-left">
                        {/* Progress */}
                        <div className="sidebar-section">
                            <h3>Progress to Release</h3>
                            <div className="progress-container">
                                <div className="progress-bar-wrapper">
                                    <div className="progress-bar" style={{ width: `${progress}%` }}></div>
                                </div>
                                <div className="progress-label">
                                    <span>{completedSteps.length} of {WORKFLOW_STEPS.length} steps</span>
                                    <span>{Math.round(progress)}%</span>
                                </div>
                            </div>
                        </div>

                        {/* Workflow Checklist */}
                        <div className="sidebar-section" style={{ flex: 1, overflowY: 'auto', minHeight: 0 }}>
                            <h3>Workflow Steps</h3>
                            <div className="checklist">
                                {WORKFLOW_STEPS.map((step, index) => {
                                    const isCompleted = completedSteps.includes(step.id);
                                    const isCurrent = index === currentStep && !isCompleted;
                                    return (
                                        <div 
                                            key={step.id} 
                                            className={`checklist-item ${isCompleted ? 'completed' : ''} ${isCurrent ? 'current' : ''}`}
                                        >
                                            <span className="check-icon">
                                                {isCompleted ? '‚úì' : index + 1}
                                            </span>
                                            <span>{step.label}</span>
                                        </div>
                                    );
                                })}
                            </div>
                            <button 
                                onClick={resetWorkflow}
                                style={{
                                    background: 'none',
                                    border: '1px solid var(--border)',
                                    color: 'var(--text-secondary)',
                                    cursor: 'pointer',
                                    fontSize: '0.75rem',
                                    padding: '0.5rem 1rem',
                                    borderRadius: '4px',
                                    marginTop: '1rem',
                                    width: '100%'
                                }}
                            >
                                Reset Workflow
                            </button>
                        </div>
                    </aside>

                    {/* Main Content */}
                    <main className="main-content">
                        {/* Code Editor */}
                        <div className="editor-container">
                            <div className="editor-header">
                                <div className="file-tab">
                                    <span className="file-icon">üìÑ</span>
                                    <span>main.cpp</span>
                                    <span className={`file-status ${fileStatus}`}></span>
                                </div>
                            </div>
                            <div className="editor-body">
                                <div className="line-numbers">{lineNumbers}</div>
                                <textarea
                                    ref={textareaRef}
                                    className="code-input"
                                    value={code}
                                    onChange={(e) => setCode(e.target.value)}
                                    onKeyDown={(e) => {
                                        if (e.key === 'Tab') {
                                            e.preventDefault();
                                            const start = e.target.selectionStart;
                                            const end = e.target.selectionEnd;
                                            const newCode = code.substring(0, start) + '    ' + code.substring(end);
                                            setCode(newCode);
                                            // Set cursor position after the inserted spaces
                                            setTimeout(() => {
                                                e.target.selectionStart = e.target.selectionEnd = start + 4;
                                            }, 0);
                                        }
                                    }}
                                    placeholder="Write your code here..."
                                    spellCheck={false}
                                    disabled={currentBranch === 'main'}
                                />
                                {currentBranch === 'main' && (
                                    <div style={{
                                        position: 'absolute',
                                        top: '50%',
                                        left: '50%',
                                        transform: 'translate(-50%, -50%)',
                                        background: 'rgba(13, 17, 23, 0.95)',
                                        padding: '1.5rem 2rem',
                                        borderRadius: '8px',
                                        border: '1px solid var(--accent-purple)',
                                        textAlign: 'center',
                                        maxWidth: '300px'
                                    }}>
                                        <div style={{ fontSize: '2rem', marginBottom: '0.5rem' }}>üåø</div>
                                        <div style={{ fontWeight: '600', marginBottom: '0.5rem' }}>First Step, Create a Branch!</div>
                                        <div style={{ fontSize: '0.8rem', color: 'var(--text-secondary)' }}>
                                            Never code directly on the main branch! It is for production ready code only. Click "Create Branch" to start.
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>

                        {/* Actions Panel */}
                        <div className="actions-panel">
                            <div className="actions-grid">
                                <button 
                                    className={`action-btn ${currentBranch === 'main' && !completedSteps.includes('create_branch') ? 'primary' : ''}`}
                                    onClick={createBranch}
                                    disabled={currentBranch !== 'main'}
                                >
                                    <span className="icon">üåø</span>
                                    Create Branch
                                </button>
                                <button 
                                    className={`action-btn ${hasUnstagedChanges ? 'warning' : ''}`}
                                    onClick={stageChanges}
                                    disabled={currentBranch === 'main' || (!hasUnstagedChanges && !hasStagedChanges)}
                                    title={currentBranch === 'main' ? 'Create a branch first' : (!hasUnstagedChanges && !hasStagedChanges) ? 'Make changes to the code first' : 'Stage your changes'}
                                >
                                    <span className="icon">üì¶</span>
                                    Stage Changes
                                </button>
                                <button 
                                    className={`action-btn ${hasStagedChanges ? 'success' : ''}`}
                                    onClick={commitChanges}
                                    disabled={!hasStagedChanges}
                                >
                                    <span className="icon">üíæ</span>
                                    Commit
                                </button>
                                <button 
                                    className="action-btn"
                                    onClick={pushChanges}
                                    disabled={!completedSteps.includes('commit') || isPushed || currentBranch === 'main'}
                                >
                                    <span className="icon">‚¨ÜÔ∏è</span>
                                    Push
                                </button>
                                <button 
                                    className="action-btn"
                                    onClick={createPR}
                                    disabled={!isPushed || prCreated}
                                >
                                    <span className="icon">üìã</span>
                                    Create PR
                                </button>
                                <button 
                                    className="action-btn"
                                    onClick={requestReview}
                                    disabled={!prCreated || reviewRequested}
                                >
                                    <span className="icon">üëÄ</span>
                                    Request Review
                                </button>
                                <button 
                                    className={`action-btn ${prApproved ? 'success' : ''}`}
                                    onClick={mergePR}
                                    disabled={!prApproved}
                                >
                                    <span className="icon">üîÄ</span>
                                    Merge PR
                                </button>
                                <button 
                                    className={`action-btn ${teammateChangePending ? 'danger' : ''}`}
                                    onClick={pullLatest}
                                >
                                    <span className="icon">‚¨áÔ∏è</span>
                                    {teammateChangePending ? 'Pull Required!' : 'Pull Latest'}
                                </button>
                            </div>
                        </div>
                    </main>

                    {/* Resize Handle */}
                    <div 
                        className={`resize-handle ${isResizing ? 'dragging' : ''}`}
                        onMouseDown={() => setIsResizing(true)}
                    />

                    {/* Right Sidebar */}
                    <aside className="sidebar-right" style={{ width: rightSidebarWidth }}>
                        {/* Branches */}
                        <div className="sidebar-section">
                            <h3>Branches</h3>
                            <div className="branch-viz">
                                {branches.map(branch => (
                                    <div 
                                        key={branch} 
                                        className={`branch-item ${branch === currentBranch ? 'active' : ''} ${branch === 'main' ? 'main' : ''}`}
                                    >
                                        <span className="branch-dot"></span>
                                        <span>{branch}</span>
                                    </div>
                                ))}
                            </div>
                        </div>

                        {/* Activity Log */}
                        <div className="log-container">
                            <h3>Activity Log</h3>
                            <div className="log-list">
                                {logs.map(log => (  
                                    <div 
                                        key={log.id} 
                                        className={`log-item ${log.message === 'Requested code review' && reviewCountdown !== null ? 'reviewing' : ''} ${log.message === 'Teammate pushed to main' && (teammateChangePending || hasConflict) ? 'teammate-pending' : ''} ${log.message === 'Changes requested' && changesRequested ? 'changes-requested' : ''}`}
                                    >
                                        <span className="log-icon">{log.icon}</span>
                                        <div className="log-content">
                                            <span className="log-message">{log.message}</span>
                                            <span className="log-detail">{log.detail}</span>
                                            {log.codeSnapshot && (
                                                <div className="code-preview">{log.codeSnapshot}</div>
                                            )}
                                            {getExplanation(log.message) && (
                                                <>
                                                    {!log.explanationOpen && (
                                                        <div 
                                                            className="explanation-toggle"
                                                            onClick={() => {
                                                                setLogs(prev => prev.map(l => 
                                                                    l.id === log.id ? { ...l, explanationOpen: true } : l
                                                                ));
                                                            }}
                                                        >
                                                            <span>Click for details</span>
                                                        </div>
                                                    )}
                                                    {log.explanationOpen && (
                                                        <div 
                                                            className="explanation-box"
                                                            onClick={() => {
                                                                setLogs(prev => prev.map(l => 
                                                                    l.id === log.id ? { ...l, explanationOpen: false } : l
                                                                ));
                                                            }}
                                                        >
                                                            {getExplanation(log.message)}
                                                        </div>
                                                    )}
                                                </>
                                            )}
                                            <div className={`log-location ${log.location}`}>
                                                <span className="location-icon">
                                                    {log.location === 'local' ? 'üíª' : log.location === 'sending' ? '‚ÜîÔ∏è' : '‚òÅÔ∏è'}
                                                </span>
                                                <span>
                                                    {log.location === 'local' ? 'Your machine' : log.location === 'sending' ? 'Syncing with GitHub' : 'On GitHub'}
                                                </span>
                                            </div>
                                        </div>
                                    </div>
                                ))}
                                {logs.length === 0 && (
                                    <div className="log-item">
                                        <span className="log-icon">üí°</span>
                                        <div className="log-content">
                                            <span className="log-message">Start by creating a branch</span>
                                            <span className="log-detail">Never code directly on the main branch!</span>
                                        </div>
                                    </div>
                                )}
                            </div>
                        </div>
                    </aside>

                    {/* Status Bar */}
                    <footer className="status-bar">
                        <div className="status-left">
                            <div className="status-item">
                                <span className={`status-dot ${hasConflict ? 'red' : hasUnstagedChanges ? 'orange' : hasStagedChanges ? 'green' : 'green'}`}></span>
                                <span>
                                    {hasConflict ? '‚ö†Ô∏è MERGE CONFLICT - Resolve before continuing' : hasUnstagedChanges ? 'Unsaved changes' : hasStagedChanges ? 'Changes staged' : 'No changes'}
                                </span>
                            </div>
                            <div className="status-item">
                                <span>‚éá {currentBranch}</span>
                            </div>
                            {teammateChangePending && (
                                <div className="status-item" style={{ color: 'var(--accent-red)' }}>
                                    <span>‚ö° Teammate pushed to main - Pull required</span>
                                </div>
                            )}
                        </div>
                        <div className="status-right">
                        </div>
                    </footer>

                    {/* Modal */}
                    {modal && (
                        <div className="modal-overlay" onClick={() => {
                            if (modal.onCancel) {
                                modal.onCancel();
                            } else {
                                setModal(null);
                            }
                        }}>
                            <div className="modal" onClick={e => e.stopPropagation()}>
                                <h2>{modal.title}</h2>
                                <p>{modal.message}</p>
                                {modal.input && (
                                    <input
                                        type="text"
                                        className="modal-input"
                                        placeholder={modal.placeholder}
                                        autoFocus
                                        onKeyDown={(e) => {
                                            if (e.key === 'Enter') {
                                                modal.onConfirm(e.target.value);
                                            }
                                        }}
                                    />
                                )}
                                <div className="modal-buttons">
                                    {!modal.hideCancel && (
                                        <button className="modal-btn cancel" onClick={() => {
                                            if (modal.onCancel) {
                                                modal.onCancel();
                                            } else {
                                                setModal(null);
                                            }
                                        }}>
                                            {modal.cancelText || 'Cancel'}
                                        </button>
                                    )}
                                    <button 
                                        className="modal-btn confirm"
                                        onClick={() => {
                                            const input = document.querySelector('.modal-input');
                                            modal.onConfirm(input ? input.value : null);
                                        }}
                                    >
                                        {modal.confirmText || 'Confirm'}
                                    </button>
                                </div>
                            </div>
                        </div>
                    )}

                    {/* Toast */}
                    {toast && (
                        <div className={`toast ${toast.type}`}>
                            <span>
                                {toast.type === 'success' ? '‚úì' : toast.type === 'error' ? '‚úó' : '‚Ñπ'}
                            </span>
                            <span>{toast.message}</span>
                        </div>
                    )}

                    {/* Celebration */}
                    {showCelebration && (
                        <div className="celebration">
                            {Array.from({ length: 50 }).map((_, i) => (
                                <div
                                    key={i}
                                    className="confetti"
                                    style={{
                                        left: `${Math.random() * 100}%`,
                                        backgroundColor: ['#58a6ff', '#3fb950', '#a371f7', '#d29922', '#f85149', '#db61a2'][Math.floor(Math.random() * 6)],
                                        animationDelay: `${Math.random() * 0.5}s`,
                                        borderRadius: Math.random() > 0.5 ? '50%' : '0'
                                    }}
                                />
                            ))}
                        </div>
                    )}
                </div>
            );
        }

        ReactDOM.createRoot(document.getElementById('app')).render(<App />);
    </script>
</body>
</html>
